import timeit
start = timeit.default_timer()
from getdat import *
import matplotlib.pyplot as plt
from scipy.signal import get_window, spectrogram
from scipy.fftpack import fft, fftfreq
import numpy as np
from ppf import ppfget
from scipy import interpolate
import math
from scipy import interpolate
from copy import deepcopy
from itertools import combinations
from scipy.sparse import csr_matrix
from scipy import signal
import matplotlib.gridspec as gridspec
from matplotlib import colors

#----------------------------------------------------------------------------------------------------------------
def phase_coherence(spectrum0,spectrum1):
	f,csd=signal.csd(spectrum0,spectrum1)
	f_xx,csd_xx=signal.csd(spectrum0,spectrum0)
	f_yy,csd_yy=signal.csd(spectrum1,spectrum1)
	coh_time=csd/np.sqrt(csd_xx*csd_yy)
	output=coh_time
	phase_time=np.angle(coh_time)
	phase_time_int=[]
	coh_time_int=[]
	i=0
	for step in phase_time:
		interpolate=np.arange(0,len(spectrum0[0]))
		original=np.linspace(0,len(spectrum0[0]),len(phase_time[0]))	
		new=np.interp(interpolate,original,phase_time[i])
		phase_time_int.append(new)
		coh_time_int.append(np.interp(interpolate,original,coh_time[i]))
		i+=1

	spectrum0_f=np.transpose(spectrum0)
	spectrum1_f=np.transpose(spectrum1)

	f_f,csd_f=signal.csd(spectrum0_f,spectrum1_f,nfft=1500)
	f_xxf,csd_xxf=signal.csd(spectrum0_f,spectrum0_f,nfft=1500)
	f_yyf,csd_yyf=signal.csd(spectrum1_f,spectrum1_f,nfft=1500)
	coh_freq=csd_f/np.sqrt(csd_xxf*csd_yyf)
	phase_freq=np.angle(coh_freq)
	phase_freq_int=[]
	coh_freq_int=[]
	i=0
	for step in phase_freq:
		interpolate=np.arange(0,len(spectrum0))
		original=np.linspace(0,len(spectrum0),len(phase_freq[0]))	
		new=np.interp(interpolate,original,phase_freq[i])
		phase_freq_int.append(new)
		coh_freq_int.append(np.interp(interpolate,original,coh_freq[i]))
		i+=1

	phase_freq_int=np.transpose(phase_freq_int)
	coh_freq_int=np.transpose(coh_freq_int)
	
	phase = (phase_freq_int+phase_time_int)/2
	coherence = (coh_freq_int+coh_time_int)/2
	phase = np.angle(coherence)
	return coherence, phase, coh_time,output
	

#--------------------------------------------------------------------------------------------------------------------------

# data settings:
pulse = 86775     # pulse number
np.savetxt('Pulse_number.txt',[pulse,0])
t0, t1 = 6, 12 # time limits [s]
f0, f1 = 00, 500    # frequency limits [kHz]

# FFT settings:
pad = 1    # no. of points the data segment is padded to when FFTing

# plot settings:
LOG = True       # log or linear plot. linear only works well for zooms
contrast = 10   # vmin = vmax/contrast for linear plot
MAX = None       # set vmax. Leave as None to use data maximum

#-------------------------------------------------------------------------------------------------------------------
f0*= 1e3
f1*= 1e3

coils = ['H302','H303','H305','T001','T002','T008']
phi_t = [92.9,103.1,110.4,3.0,42.1,257.1]
phi_rad = np.radians(phi_t)

spectrum_array=[]
times, freqs = [], []

#These are to find common range in which ALL probes record data
t_hold=[0,0]
probe_tstarts=[]
probe_tstops=[]
i=0

for coil in coils:
	print('DA/C1M-'+coil)
	data, time, nw, title, units, ier=getdat('DA/C1M-'+coil, pulse) #reads in magnetic data
	data_ant, time_ant, nw_ant, title_ant, units_ant, ier_ant = getdat('SC/FANT', pulse) #reads in antenna data #there isnt any antenna signal in 86775
	header_fra, datw_fra, data_fra ,x_fra, time_fra, ier_fra = ppfget(pulse, "ICRH", "FRA") #reads in ICRH data from antennas A-E
	header_frb, datw_frb, data_frb ,x_frb, time_frb, ier_frb = ppfget(pulse, "ICRH", "FRB")
	header_frc, datw_frc, data_frc ,x_frc, time_frc, ier_frc = ppfget(pulse, "ICRH", "FRC")
	header_frd, datw_frd, data_frd ,x_frd, time_frd, ier_frd = ppfget(pulse, "ICRH", "FRD")
	header_fre, datw_fre, data_fre ,x_fre, time_fre, ier_fre = ppfget(pulse, "ICRH", "FRE")
	header_ptot, datw_ptot, data_ptot ,x_ptot, time_ptot, ier_ptot = ppfget(pulse, "ICRH", "PTOT") #reads in ICRH power data

	all_antenna = [] #adds non zero antenna arrays to a bigger array
	if len(data_fra)>0:
		all_antenna.append(data_fra)
	if len(data_frb)>0:
		all_antenna.append(data_frb)
	if len(data_frc)>0:
		all_antenna.append(data_frc)
	if len(data_frd)>0:
		all_antenna.append(data_frd)
	if len(data_fre)>0:
		all_antenna.append(data_fre)
	all_antenna = np.array(all_antenna)

	antenna_no = np.arange(0,len(all_antenna)) #list of antenna indexes
	antenna_pairs = np.array(list(combinations(antenna_no,2)))  #all pair combinations for the 5 antennas
	differences = [] #array of frequency differences between antenna 
	for pair in antenna_pairs:
		differences.append(abs(all_antenna[pair[0]]-all_antenna[pair[1]])/1000)
	differences = np.array(np.unique(differences)[np.nonzero(np.unique(differences))]) #gives the beat ICRH frequencies

	time_ptot-=40
	time_icrh = time_fra[(data_ptot>0)*(time_ptot<t1)]-40 #times where ICRH power is non-zero

	time_norm = time[0]
	time -= time_norm           # zero the time
	df = len(time)/time[-1]     # sampling frequency 
	print('Sampling frequency:',df)

	#makes all spectograms the same shape
	if df==1000000:
		nfft = 6000 #number of data points used in each block for the FFT.
		noverlap = 3000 #overlap between windows
	else:
		nfft = 12000 #number of data points used in each block for the FFT.
		noverlap = 6000 #overlap between windows

	if noverlap >= nfft:
	    noverlap = nfft/2.0
	Window = get_window('hanning', nfft)  #hanning window for FFT, nfft is the number of samples in the window
	cMap   = plt.get_cmap('inferno') #inferno

	#takes spectograph (FFT)	    
	#spectrum, f, t,im=plt.specgram(data, Fs=df, NFFT=nfft, window=Window, mode='magnitude', cmap=cMap, noverlap=noverlap, detrend='mean', scale='linear', pad_to=pad*nfft ) 
	
	#short time fourier transform 
	f,t,spectrum=signal.stft(data,nperseg=nfft,fs=df,nfft=nfft,window=Window)

	t = t+time_norm - 40.0  # magnetic data doesn't always start at 40.0??

	# only plot the window of interest:
	i0, i1 = np.argmin(abs(t-t0)), np.argmin(abs(t-t1)) # time limit indices #argmin returns index of minimum
	j0, j1 = np.argmin(abs(f-f0)), np.argmin(abs(f-f1)) # frequency limit indices
	ts, fs, spectrum = t[i0:i1], f[j0:j1]/1e3, spectrum[j0:j1, i0:i1]/10.0 #new time, freq and spectrum in range
	
	if len(spectrum[0])==2930:
		spectrum = np.delete(spectrum, 2929, 1)  #deletes end column

	#for beat_freq in differences:
		#plt.scatter(time_icrh,np.ones(len(time_icrh))*beat_freq, c='red')
	#plt.imshow(np.log10(np.absolute(spectrum)),interpolation='nearest', extent=[6,12,0,500], aspect='auto', origin='lower')
	#plt.show()

	print(spectrum.shape)
	spectrum_array.append(spectrum)
	times.append(ts)
	freqs.append(fs)

spectrum_array=np.array(spectrum_array)
#times=np.array(times)
#freqs=np.array(freqs)

avg = (spectrum_array[0]+spectrum_array[1]+spectrum_array[2]+spectrum_array[3]+spectrum_array[4]+spectrum_array[5])/6
print(avg)
#plt.imshow(np.log10(np.absolute(avg)))
#plt.show()

signal_no = np.arange(0,len(spectrum_array))
pairs = np.array(list(combinations(signal_no,2)))  #All pair combinations for the 6 probes (0,1,2,3,4,5)
print('pairs',pairs)

test=[]
residual_sum=np.zeros([21,2048,2929])
relative_coil_pos = []
all_phase = []
for pair in pairs:
	#coherence = phase_coherence(spectrum_array[pair[0]],spectrum_array[pair[1]])[0]
	#cohere_time = phase_coherence(spectrum_array[pair[0]],spectrum_array[pair[1]])[3]
	
	kernal=1/(40*40)*(np.ones((40,40))) #have to play around with size to find optimum
	csd_xy = signal.convolve2d((spectrum_array[pair[0]]*np.conj(spectrum_array[pair[1]])),kernal,mode='same')
	#csd_xy = spectrum_array[pair[0]]*np.conj(spectrum_array[pair[1]])
	#print('One convlution done')
	
	phase=np.angle(csd_xy)
	all_phase.append(phase)
	rel_angle = abs(phi_rad[pair[0]]-phi_rad[pair[1]])
	relative_coil_pos.append(rel_angle) #array of relative coil positions
	test.append([rel_angle,phase[517][500]])


test=np.array(np.transpose(test))
#print(test)
#plt.scatter(test[0],test[1])
#plt.xlim(0,5)
#plt.ylim(-7,7)
#plt.show()

mode_number_spec = np.zeros([3000,2000]) #array of zeros for mode number spectogram
modes=np.arange(-7,8) #list of mode number from -10 to 10

#finding the position in the spectogram of the ICRH lines
ICRH_freq_index = differences*mode_number_spec.shape[0]/((f1-f0)/1000)
ICRH_time_index = (time_icrh-6)*mode_number_spec.shape[1]/(6)
#print(time_icrh)
#print(mode_number_spec.shape[1])
#print(t1-t0)
#print('ICRH freq',ICRH_freq_index,ICRH_freq_index+1,ICRH_freq_index-1)
#print('ICRH time',ICRH_time_index[0],ICRH_time_index[-1])
#print(differences)

i=0
#for a in all_phase[0]: #steps through all phase freq (2048)
for a in range(0,2999):
	print(i)
	j=0
	#for b in all_phase[0][0]: #steps through all phase time (2929)
	for b in range(0,1999):
		if np.log10(np.absolute(avg[i][j]))>-3.5:	
			if np.min(abs(i-ICRH_freq_index )) in range(0,3) and j>= ICRH_time_index[0] and j<= ICRH_time_index[-1]:
				mode_number_spec[i][j]=-11
			else:
				i
				phases = []
				k=0
				for pair in all_phase: #steps through each probe pair 
					phases.append(all_phase[k][i][j]) #puts the [i][j]'th phase of each pair into an array to check residuals 
					k+=1

				residual_array = []
				for mode in modes:
					max_shift = int(math.ceil((abs(mode)*np.max(relative_coil_pos))/(2*np.pi))) #optimum number of shifts for residual lines
					if mode<0:
						b=0
						total = []
						for phase in phases:
							phase_residuals = []
							for shift in range (0,max_shift+1):	
								x=np.linspace(0,2*np.pi,200)		
								#print(phases[b],relative_coil_pos[b])
								#print(phases[b]-(mode*relative_coil_pos[b]+shift*2*np.pi))
								#plt.plot(relative_coil_pos,phases)
								#plt.scatter(relative_coil_pos[b],phases[b],color='green')
								#plt.plot(x,x*mode+shift*2*np.pi,c='red')
								#plt.scatter(relative_coil_pos[b],relative_coil_pos[b]*mode+shift*2*np.pi,c='orange')
								#plt.xlim(0,2*np.pi)
								#plt.ylim(-10,10)
								#plt.show()
								residual = (phase-(mode*relative_coil_pos[b]+shift*2*np.pi))**2
								phase_residuals.append(residual)
							#print('phase residuals',phase_residuals)
							min_residual = np.min(phase_residuals) #smallest residual for one point
							#print(min_residual)
							total.append(min_residual) #list of all the points minimum residuals 
							b+=1
						#print(total)
						residual_array.append([sum(total),mode])
						#x=np.linspace(0,2*np.pi,200)
						#plt.scatter(relative_coil_pos,phases)
						#plt.plot(x,x*mode,c='red')
						#plt.plot(x,x*mode+2*np.pi,c='red',label=mode)
						#plt.plot(x,x*mode+4*np.pi,c='red')
						#plt.plot(x,x*mode+6*np.pi,c='red')
						#plt.plot(x,x*mode+8*np.pi,c='red')
						#plt.plot(x,x*mode+10*np.pi,c='red')
						#plt.axvline(x=relative_coil_pos[2],c='green')
						#plt.xlim(0,2*np.pi)
						#plt.ylim(-np.pi,np.pi)
						#plt.legend()
						#plt.show()
					
					if mode==0:			
						residual_array.append([sum(np.array(phases)**2),mode])

					if mode>0:
						b=0
						total = []
						for phase in phases:
							phase_residuals = []
							for shift in range (0,max_shift+1):
								residual = (phase-(mode*relative_coil_pos[b]-shift*2*np.pi))**2
								phase_residuals.append(residual)
							min_residual = np.min(phase_residuals) #smallest residual for one point
							total.append(min_residual) #list of 
							b+=1
						residual_array.append([sum(total),mode])
						#x=np.linspace(0,2*np.pi,200)
						#plt.scatter(relative_coil_pos,phases)
						#plt.plot(x,x*mode,c='red')
						#plt.plot(x,x*mode-2*np.pi,c='red',label=mode)
						#plt.plot(x,x*mode-4*np.pi,c='red')
						#plt.plot(x,x*mode-6*np.pi,c='red')
						#plt.plot(x,x*mode-8*np.pi,c='red')
						#plt.plot(x,x*mode-10*np.pi,c='red')
						#plt.axvline(x=relative_coil_pos[2],c='green')
						#plt.xlim(0,2*np.pi)
						#plt.ylim(-np.pi,np.pi)
						#plt.legend()
						#plt.show()
				

				residual_array=np.array(residual_array)
				#modies=[-10,-9,-8,-7,-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6,7,8,9,10]
				#plt.scatter(modies,residual_array[:,0])
				#plt.show()
				#print('\n\n',residual_array)
				mode_number = residual_array[np.argmin(residual_array[:,0])][1]
				mode_number_spec[i][j]=-mode_number
			
		else:
			mode_number_spec[i][j]=-11
		j+=1
	i+=1

np.savetxt('mode_number_image.dat',mode_number_spec)

# define the color map
cmap = colors.ListedColormap(['white','steelblue','sienna','lightgreen','magenta','navy','red','gold','greenyellow','lightcoral','cyan','blueviolet','darkcyan','green','lightpink','darkorange','lime','violet','blue','deeppink','lightskyblue','yellow'])
bounds = [-11.5,-10.5,-9.5,-8.5,-7.5,-6.5,-5.5,-4.5,-3.5,-2.5,-1.5,-0.5,0.5,1.5,2.5,3.5,4.5,5.5,6.5,7.5,8.5,9.5,10.5]
norm = colors.BoundaryNorm(bounds, cmap.N)
plt.imshow(mode_number_spec,cmap=cmap, norm=norm)
plt.colorbar(ticks=[-10,-9,-8,-7,-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6,7,8,9,10])
plt.gca().invert_yaxis()
stop = timeit.default_timer()
print('Time: ', stop - start)
plt.show()

